-- #################################
-- RECREACIÓN DE ESTRUCTURA Y TRIGGERS DE AUTH
-- #################################

-- NOTA: La tabla 'perfiles' ya existe, solo nos enfocaremos en las que faltan.

-- Tabla para Categorías (Mantener)
CREATE TABLE categorias (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre TEXT NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabla para Productos (CORRECCIÓN: categoria_id PERMITE NULLS)
CREATE TABLE productos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    categoria_id BIGINT REFERENCES categorias(id), -- PUEDE SER NULL AHORA
    nombre TEXT NOT NULL,
    descripcion TEXT,
    precio NUMERIC(10, 2) NOT NULL,
    stock INTEGER NOT NULL DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE INDEX idx_productos_categoria_active ON productos (categoria_id, is_active);

-- Tabla para el Carrito (Un carrito por usuario)
CREATE TABLE carritos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES public.perfiles(id) UNIQUE, 
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabla para Pedidos
CREATE TABLE pedidos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES public.perfiles(id),
    estado TEXT NOT NULL DEFAULT 'pendiente',
    total NUMERIC(10, 2) NOT NULL,
    direccion_envio TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tablas de Ítems
CREATE TABLE items_carrito (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    carrito_id BIGINT REFERENCES carritos(id),
    producto_id BIGINT REFERENCES productos(id),
    cantidad INTEGER NOT NULL CHECK (cantidad > 0),
    CONSTRAINT unique_item_in_cart UNIQUE (carrito_id, producto_id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE items_pedido (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pedido_id BIGINT REFERENCES pedidos(id),
    producto_id BIGINT REFERENCES productos(id),
    nombre_producto TEXT NOT NULL,
    precio_unitario NUMERIC(10, 2) NOT NULL,
    cantidad INTEGER NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ----------------------------------------------------
-- RE-CREACIÓN DE FUNCIONES DE ROL/AUTH (CRÍTICO)

-- Función para inicializar perfiles al registrarse un usuario
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.perfiles (id, nombre, role)
  VALUES (new.id, new.email, 'user');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger: se dispara después de crear un usuario en auth.users
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Función para inyectar el rol 'admin' en el JWT (CORRECCIÓN FINAL)
CREATE OR REPLACE FUNCTION public.custom_claims()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE auth.users 
  SET raw_app_meta_data = 
    raw_app_meta_data || json_build_object('role', NEW.role)::jsonb
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger: se dispara tras actualizar el rol en public.perfiles
CREATE TRIGGER update_auth_role
AFTER UPDATE OF role ON public.perfiles
FOR EACH ROW
WHEN (OLD.role IS DISTINCT FROM NEW.role)
EXECUTE FUNCTION public.custom_claims();



-- HABILITAR RLS EN TODAS LAS TABLAS CREADAS
ALTER TABLE public.perfiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.categorias ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.productos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.carritos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.items_carrito ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pedidos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.items_pedido ENABLE ROW LEVEL SECURITY;

-- POLÍTICAS DE ACCESO (ADMIN Y PÚBLICO)

-- PERFILES (Solo tú, Admin ve todo)
CREATE POLICY "Usuarios pueden ver/editar su propio perfil" ON public.perfiles FOR ALL USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
CREATE POLICY "Administradores pueden ver todos los perfiles" ON public.perfiles FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

-- CATEGORÍAS (Público lee, Admin CRUD)
CREATE POLICY "El público puede leer categorias" ON public.categorias FOR SELECT USING (true);
CREATE POLICY "Admin CRUD categorias" ON public.categorias FOR ALL USING (auth.jwt() ->> 'role' = 'admin') WITH CHECK (auth.jwt() ->> 'role' = 'admin');

-- PRODUCTOS (Público lee activos, Admin CRUD total)
CREATE POLICY "Público: SELECT Activos" ON public.productos FOR SELECT USING (is_active = TRUE);
CREATE POLICY "Admin: CRUD total" ON public.productos FOR ALL USING (auth.jwt() ->> 'role' = 'admin') WITH CHECK (auth.jwt() ->> 'role' = 'admin');

-- CARRITOS Y ITEMS (Solo propietario puede manipular)
CREATE POLICY "Propietario puede manejar carrito" ON public.carritos FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Propietario puede manejar items de su carrito" ON public.items_carrito FOR ALL USING (EXISTS (SELECT 1 FROM carritos WHERE carritos.id = items_carrito.carrito_id AND carritos.user_id = auth.uid())) WITH CHECK (EXISTS (SELECT 1 FROM carritos WHERE carritos.id = items_carrito.carrito_id AND carritos.user_id = auth.uid()));

-- PEDIDOS Y ITEMS (Usuario lee solo suyos, Admin lee todo)
CREATE POLICY "Usuarios solo leen sus pedidos" ON public.pedidos FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admin puede manejar pedidos" ON public.pedidos FOR ALL USING (auth.jwt() ->> 'role' = 'admin') WITH CHECK (auth.jwt() ->> 'role' = 'admin');
CREATE POLICY "Usuarios leen items de sus pedidos" ON public.items_pedido FOR SELECT USING (EXISTS (SELECT 1 FROM pedidos WHERE pedidos.id = items_pedido.pedido_id AND pedidos.user_id = auth.uid()));
CREATE POLICY "Admin puede manejar items de pedido" ON public.items_pedido FOR ALL USING (auth.jwt() ->> 'role' = 'admin') WITH CHECK (auth.jwt() ->> 'role' = 'admin');

















-- HABILITAR RLS EN TABLAS RECIÉN CREADAS
ALTER TABLE public.categorias ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.productos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.carritos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.items_carrito ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pedidos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.items_pedido ENABLE ROW LEVEL SECURITY;

-- ----------------------------------------------------------------
-- POLÍTICAS DE ACCESO (SALVANDO LAS POLÍTICAS DE PERFILES YA EXISTENTES)
-- ----------------------------------------------------------------

-- CATEGORÍAS (Público lee, Admin CRUD)
DROP POLICY IF EXISTS "El público puede leer categorias" ON public.categorias;
DROP POLICY IF EXISTS "Admin CRUD categorias" ON public.categorias;
CREATE POLICY "El público puede leer categorias" ON public.categorias FOR SELECT USING (true);
CREATE POLICY "Admin CRUD categorias" ON public.categorias FOR ALL USING (auth.jwt() ->> 'role' = 'admin') WITH CHECK (auth.jwt() ->> 'role' = 'admin');

-- PRODUCTOS (Público lee activos, Admin CRUD total)
DROP POLICY IF EXISTS "Público: SELECT Activos" ON public.productos;
DROP POLICY IF EXISTS "Admin: CRUD total" ON public.productos;
CREATE POLICY "Público: SELECT Activos" ON public.productos FOR SELECT USING (is_active = TRUE);
CREATE POLICY "Admin: CRUD total" ON public.productos FOR ALL USING (auth.jwt() ->> 'role' = 'admin') WITH CHECK (auth.jwt() ->> 'role' = 'admin');

-- CARRITOS Y ITEMS (Solo propietario puede manipular)
DROP POLICY IF EXISTS "Propietario puede manejar carrito" ON public.carritos;
DROP POLICY IF EXISTS "Propietario puede manejar items de su carrito" ON public.items_carrito;
CREATE POLICY "Propietario puede manejar carrito" ON public.carritos FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Propietario puede manejar items de su carrito" ON public.items_carrito FOR ALL USING (EXISTS (SELECT 1 FROM carritos WHERE carritos.id = items_carrito.carrito_id AND carritos.user_id = auth.uid())) WITH CHECK (EXISTS (SELECT 1 FROM carritos WHERE carritos.id = items_carrito.carrito_id AND carritos.user_id = auth.uid()));

-- PEDIDOS Y ITEMS (Usuario lee solo suyos, Admin lee todo)
DROP POLICY IF EXISTS "Usuarios solo leen sus pedidos" ON public.pedidos;
DROP POLICY IF EXISTS "Admin puede manejar pedidos" ON public.pedidos;
DROP POLICY IF EXISTS "Usuarios leen items de sus pedidos" ON public.items_pedido;
DROP POLICY IF EXISTS "Admin puede manejar items de pedido" ON public.items_pedido;

CREATE POLICY "Usuarios solo leen sus pedidos" ON public.pedidos FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admin puede manejar pedidos" ON public.pedidos FOR ALL USING (auth.jwt() ->> 'role' = 'admin') WITH CHECK (auth.jwt() ->> 'role' = 'admin');
CREATE POLICY "Usuarios leen items de sus pedidos" ON public.items_pedido FOR SELECT USING (EXISTS (SELECT 1 FROM pedidos WHERE pedidos.id = items_pedido.pedido_id AND pedidos.user_id = auth.uid()));
CREATE POLICY "Admin puede manejar items de pedido" ON public.items_pedido FOR ALL USING (auth.jwt() ->> 'role' = 'admin') WITH CHECK (auth.jwt() ->> 'role' = 'admin');














DROP POLICY IF EXISTS "Admin: CRUD total" ON public.productos;

-- Política que permite a CUALQUIER USUARIO LOGUEADO insertar/editar productos
CREATE POLICY "Admin: CRUD total"
ON public.productos FOR ALL
USING (auth.role() = 'authenticated') 
WITH CHECK (auth.role() = 'authenticated');











-- ELIMINAR POLÍTICAS DE ESCRITURA SIN RESTRICCIÓN DE ROL
DROP POLICY IF EXISTS "Admin CRUD Storage Access 16wiy3a_1" ON storage.objects; -- UPDATE
DROP POLICY IF EXISTS "Admin CRUD Storage Access 16wiy3a_0" ON storage.objects; -- INSERT
DROP POLICY IF EXISTS "Admin CRUD Storage Access 16wiy3a_2" ON storage.objects; -- DELETE


-- POLÍTICA FINAL: PERMITE CRUD SOLO SI EL ROL ES 'ADMIN'
CREATE POLICY "Admin CRUD Storage Access"
ON storage.objects FOR ALL
TO authenticated
USING (
    bucket_id = 'product-images' AND (auth.jwt() ->> 'role') = 'admin'
)
WITH CHECK (
    (auth.jwt() ->> 'role') = 'admin'
);















-- FUNCIÓN PARA VERIFICAR SI EL USUARIO LOGUEADO ES ADMIN
CREATE OR REPLACE FUNCTION public.is_admin_user()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.perfiles
    WHERE id = auth.uid() AND role = 'admin'
  );
$$;








-- Agregar la columna image_path a la tabla productos
ALTER TABLE public.productos
ADD COLUMN image_path TEXT NULL;

-- NOTA: La columna debe ser de tipo TEXT para guardar la ruta del archivo.








-- ELIMINAR LA RESTRICCIÓN DE LLAVE FORÁNEA (FK)
ALTER TABLE public.productos
DROP CONSTRAINT IF EXISTS productos_categoria_id_fkey;









-- Política de Lectura (SELECT) para Todos
CREATE POLICY "Allow public read access"
on storage.objects for select
to public
using (bucket_id = 'product-images');















-- 1. RE-CREACIÓN DE LA FUNCIÓN handle_new_user (CORRECCIÓN DE OAUTH)
-- Usamos COALESCE para asegurar que el 'nombre' no sea nulo, solucionando fallos de registro por Google/OAuth.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.perfiles (id, nombre, role)
  VALUES (new.id, COALESCE(new.email, 'Usuario OAuth ' || new.id), 'user');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. RE-CREACIÓN DEL TRIGGER PARA INSERTAR EN 'perfiles'
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 3. RE-CREACIÓN DE LA FUNCIÓN DE ROL ADMIN (CRÍTICO)
CREATE OR REPLACE FUNCTION public.custom_claims()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE auth.users 
  SET raw_app_meta_data = 
    raw_app_meta_data || json_build_object('role', NEW.role)::jsonb
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4. RE-CREACIÓN DEL TRIGGER DE ROL ADMIN
CREATE TRIGGER update_auth_role
AFTER UPDATE OF role ON public.perfiles
FOR EACH ROW
WHEN (OLD.role IS DISTINCT FROM NEW.role)
EXECUTE FUNCTION public.custom_claims();

















-- ELIMINAR EL TRIGGER DE AUTH
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- ELIMINAR LA FUNCIÓN (Puede fallar si aún está en uso)
DROP FUNCTION IF EXISTS public.handle_new_user();




CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  -- La versión más permisiva: usa el email o un ID si el email falla
  INSERT INTO public.perfiles (id, nombre, role)
  VALUES (new.id, COALESCE(new.email, 'Usuario OAuth ' || new.id::text), 'user');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;





CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  -- La versión más permisiva: usa el email o un ID si el email falla
  INSERT INTO public.perfiles (id, nombre, role)
  VALUES (new.id, COALESCE(new.email, 'Usuario OAuth ' || new.id::text), 'user');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;



CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();












  -- POLÍTICA FALTANTE: Permite al usuario autenticado INSERTAR y MODIFICAR SUS propios pedidos
CREATE POLICY "Usuario: Crear y actualizar propio pedido"
ON public.pedidos FOR ALL
TO authenticated
USING (
    -- Permite SELECT/DELETE si el pedido es suyo
    auth.uid() = user_id
)
WITH CHECK (
    -- Permite INSERT/UPDATE si el pedido pertenece al usuario que lo crea
    auth.uid() = user_id
);








DROP POLICY IF EXISTS "Usuario: Crear y actualizar propio pedido" ON public.pedidos;
DROP POLICY IF EXISTS "Admin puede manejar pedidos" ON public.pedidos;


-- Permite a CUALQUIER usuario autenticado INSERTAR y MODIFICAR pedidos.
CREATE POLICY "Usuarios autenticados pueden escribir pedidos"
ON public.pedidos FOR ALL
TO authenticated
USING (TRUE) 
WITH CHECK (TRUE);














-- Elimina las políticas actuales de escritura en pedidos
DROP POLICY IF EXISTS "Usuario: Crear y actualizar propio pedido" ON public.pedidos;
DROP POLICY IF EXISTS "Admin puede manejar pedidos" ON public.pedidos;

-- Crea la política que solo verifica la autenticación (Solución de Desbloqueo)
CREATE POLICY "Usuarios autenticados pueden escribir pedidos"
ON public.pedidos FOR ALL
TO authenticated
USING (TRUE) 
WITH CHECK (TRUE);







DROP POLICY IF EXISTS "Admin puede manejar items de pedido" ON public.items_pedido;
-- Permite a CUALQUIER usuario autenticado INSERTAR y MODIFICAR ítems de pedido.
-- El CHECK (TRUE) permite la inserción sin verificar la propiedad.
CREATE POLICY "Usuarios autenticados pueden escribir items_pedido"
ON public.items_pedido FOR ALL
TO authenticated
USING (TRUE) 
WITH CHECK (TRUE);